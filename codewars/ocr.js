function ocr(image) {
    // Apply a filter to increase the contrast of the numbers to the paper
    let sum = image.pixels.reduce((a, b) => a + b)
    let avg = sum / (image.width * image.height) // May need to change this

    // Find all black pixes and run the connected algorithm to get all points that are connected together
    let numbers = getConnected(image)
    console.log(numbers)
    // for each section, determine what character it likely is 
    //      Do this by 
    let out = [];
    for (let i = 0; i < image.height; i++) {
        let row = [];
        for (let j = 0; j < image.width; j++) {
            row.push(image.pixels[i*image.width + j] > avg ? 255 : 0)
        }
        out.push(row);
    }

    return out
}

// nodes are the list of indices of pixels that are white in the image (each index is between 0 and w*h)
function getConnected(image) {
    let numbers = [];
    let nodes = image.pixels.map((v, i) => v == 0 ? i : undefined).filter(a => a != undefined) // not sure if this is efficient
    let visited = new Set();

    for(node of nodes) {
        if(!visited.has(node)) {
            numbers.push(dfsUtil(image, node, visited))
        }
    }

    return numbers
}

function dfsUtil(image, node, visited) {
    // utility recursive function to perform depth first search on node
    let out = []
    visited.add(node);

    for(n of neighbors(node, image.width, image.height)) {
        if(!visited.has(n)) {
            out.concat(dfsUtil(image, n, visited));
        }
    }

    return out
}

function neighbors(node, width, height) {
    let [x, y] = [Math.floor(node / width), node % width]
    return [[x-1, y], [x+1, y], [x, y-1], [x,y+1]].filter(([a, b]) => a >= 0 && a < width && b >= 0 && b < height).map(([a, b]) => a*width + b)
}

class Image {
    constructor(w, h, data) {
        this.pixels = data.slice();
        this.width = w;
        this.height = h;
    }
}

let image = new Image(13, 18,
    [0xff, 0xff, 0xff, 0xc0, 0xad, 0xad, 0xad, 0xad, 0xaf, 0xe8, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xda, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0x28, 0x2e, 0xe, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
        0xff, 0xd3, 0x42, 0x0, 0x0, 0x3a, 0x44, 0x12, 0x0, 0xe, 0x81, 0xf3, 0xff,
        0xd9, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xff,
        0xb0, 0x0, 0xb, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x35, 0x0, 0xa, 0xf1,
        0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
        0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
        0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
        0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
        0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
        0xb2, 0x0, 0x8, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x28, 0x0, 0xe, 0xf5,
        0xe8, 0x1e, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x6b, 0xff]);

for(row of ocr(image)) {
    console.log(...row.map(n => n.toString().padStart(3, ' ')));
}

console.log()